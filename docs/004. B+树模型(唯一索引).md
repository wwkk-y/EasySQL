# B+树模型(唯一索引)

> 参考文献:
> - [B+树详解](https://ivanzz1001.github.io/records/post/data-structure/2018/06/16/ds-bplustree)
> - [MySQL B+树相对于B树的区别及优势](https://juejin.cn/post/7117516433386373133)

## 结构

> 对于唯一索引B+树, 不能包含重复的key

这里采取的策略是, 一个父节点对应一个子页面(子节点集合), 父节点的值是子节点里的最大值, 举个例子, 如下

```text
           +-----------+-----------+-----------+
           |     3     |     7     |     8     |
           +-----------+-----------+-----------+
               /              |         /
+-----+-----+-----+  +-----+-----+   +-----+
|  1  |  2  |  3  |  |  5  |  7  |   |  8  |
+-----+-----+-----+  +-----+-----+   +-----+
| dat | dat | dat |  | dat | dat |   | dat |
+-----+-----+-----+  +-----+-----+   +-----+
```

## 算法

### 搜索

1. 当前页面 nodePage 设为 rootPage, 从根页面开始搜索关键字 key
2. 在当前页面已有 keys 里找第一个 >= key 的位置 leI (large equal index)
    > 由于 keys 是有序的, 可以采取二分查找, 当然这里数据量比较小, 直接顺序搜索性能也可能更好
3. 判断 leI 超出当前页面已有 keys 的大小
   1. 表示当前页面最大的节点索引都没有 key 大, 即要找的元素不存在
   2. else 判断当前页面是不是叶子页面
      1. 如果是, 判断 key == keys[leI]
         1. 如果不成立, 表示要找的元素不存在
         2. 如果成立, 表示找到了对应元素, 根据需求返回数据页或者节点
      2. 如果不是, 表示 key 在当前页面第 leI 个节点的范围里, 继续去子页面里搜索, 当前页面 nodePage 设为 nodePage.children[leI], 执行第2步

### 插入

